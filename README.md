# JVM
java进程实现的虚拟内存管理器，java代码依赖jvm编译运行javac字节码达到跨平台运行
### 内存管理
新生代：eden区和survivor区

老年代：tenured 

永久区：方法区

### GC 算法
复制、标记-清除和标记-压缩

### 垃圾回收器
ParNew GC
G1 GC

---
# NIO

同步非阻塞IO，Selector管理多个线程，当事件发生不会阻塞
###  核心组成
Channels

Buffers

Selectors
### channels 和buffer
channels可读写，支持异步读写

buffer单向读或者写

### Selectors
检查一个或多个Java NIO 通道 实例，并确定哪些通道准备好进行读取或写入等操作。通过这种方式，单个线程可以管理多个通道，从而管理多个网络连接

---
# 并发编程
### 三要素
原子性

有序性

可见性

### 状态
新建

就绪

运行

阻塞

死亡 
### 线程协作
wait notify

synchronized 
### 乐观锁和悲观锁
悲观锁：每次操作都会加锁，造成线程阻塞。 synchronized

乐观锁：每次操作都不会加锁，假设不会有冲突，如果有冲突回重试，不会造成线程阻塞

---
# spring和ORM框架
对象关系映射模式是一种为了解决面向对象与关系数据库存在的互不匹配的现象技术

### 主流框架
Hibernate

iBATIS

mybatis

eclipseLink

JFinal

### 优缺点
1、提高开发效率，降低成本
2、对象化
3、可移植
4、处理多表l联查、where复杂查询 ORM语法复杂
---
# MYSQL数据库

### 事务
原子性

一致性

隔离性

持久性

### 并发一致性
丢失修改

读脏数据

不可重复读

幻读

### 隔离级别
未提交读

提交读

可重复读

可串行化

---
# 分库分表
分库： 一个库分成多个相同库，访问时访问一个

分表：一个表数据放到多个表中，操作对应某一个表 

### 垂直拆分
- 每个库表结构不一样
- 每个库表数据至少一列一样
- 每个库表并集是全集数据
#### 优点
业务清晰，维护简单。
#### 缺点
单表读写压力大，开发复杂
### 水平拆分
- 每个库表结构一样
- 每个库表数据不一样
- 并集是全量数据
#### 优点
数据量减少，性能提高，表结构不变，程序改造少
#### 缺点
扩容难，拆分规则很难抽象

---
# RPC和微服务
远程方法调用，像调用本地服务一样调用远程服务 ，Rcp介于传输层和应用层之间，比http更可靠

### 过程
1、 本地调用某个函数方法

2、RPC框架把调用信息封装起来，序列化后通过网络传输发送到远程服务器

3、远程服务收到调用请求后，RPC反序列化获得调用信息，执行对应方法序列化结果发送回本地服务

4、本地机器反序列化结果

---
# 分布式缓存

### cache aside模式
1、读取失效 ：没有命中，查询db，成功把数据写入缓存
2、读取命中：读取cache数据
3、更新：数据更新到db，失效缓存

### Read/Write Through模式
缓存代理了DB读取、写入逻辑

### Write Behind Cahing模式
所有操作走缓存，缓存的数据异步写入db

### 缓存失效
缓存对象设置超时时间

### 缓存淘汰
在存储空间不足，主动释放缓存对象

---
# 分布式消息队列
- 消息转存
- 消息投递

### MQ基本特性

- RPC通信

- 存储系统

- 高可用

- 推拉模型

- 消息投放

- 消息投放对象
